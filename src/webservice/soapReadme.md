<div style='display: none'>
@tableofcontents @section README

To view this file in the Firefox web browser, download readmeviewer.html from https://www.genivia.com/files/readmeviewer.html.zip, unzip and copy it to the same directory where this soapReadme.md file is located, then open it in Firefox to view the contents of soapReadme.md.

This markdown file is compatible with Doxygen.
</div>

## Overview {#doc-overview}

This report was generated by soapcpp2 v2.8.70 for interface file [webservice_source.h](webservice_source.h) with options -r  -S -L -j 

### Tools

The **wsdl2h** command line tool takes a set of WSDL and XSD files to generate a data binding interface file.  This interface file is similar to a C/C++ header file and contains declarations of C/C++ types and functions with explanatory comments, directives, and annotations.  Types are declared in this interface file as serializable.  Functions are declared as Web service operations for the client and server sides.

The **soapcpp2** command line tool takes an interface file (i.e. a header file) such as [webservice_source.h](webservice_source.h) to generate the data binding implementation.  This implementation includes XML serializers and source code for the client and server side.  An interface file for soapcpp2 can be a regular C/C++ header file with type and function declarations (without code), and include annotations to declare XML schema-related properties.

### Files

The following c++ source code files were generated by soapcpp2 for interface file [webservice_source.h](webservice_source.h):

- [soapStub.h](soapStub.h) contains an annotated copy of [webservice_source.h](webservice_source.h) and of the imported files (if any), where most of the information in this report [soapReadme.md](soapReadme.md) is sourced from (this header file also #includes "stdsoap2.h")
- [soapH.h](soapH.h) declares allocation and (de)serialization functions for each C/C++ type, to #include in projects (this header file also #includes "soapStub.h")
- [soapC.cpp](soapC.cpp) defines allocation and (de)serialization functions for each C/C++ type, to compile with a project
- See [Web service class](#doc-server) for the server-side source code files to use

Also compile stdsoap2.cpp (and dom.cpp if XML DOM is used) with a project (or link libgsoapssl++.a) and use the following compile-time options:

- `-DWITH_OPENSSL` to enable HTTPS with OpenSSL
- `-DWITH_GNUTLS` to enable HTTPS with GNUTLS
- `-DWITH_DOM` is required when using the WS-Security plugin
- `-DWITH_GZIP` to enable message compression

See the gSOAP documentation for additional options.

### Contents

This report has the following contents describing the data binding interface types, and the client- and the server-side operations (if any):

- [class, struct and union types](#doc-classes)
- [typedefs](#doc-typedefs)
- [summary of serializable types](#doc-types)
- [schemas and namespaces](#doc-namespaces)
- [Web service class](#doc-server) lists the methods to implement when developing a service

[![][1] To top](#)


## Class, Struct and Union Types {#doc-classes}

The table below lists the classes, structs and unions declared in [webservice_source.h](webservice_source.h) or that are imported:

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th></tr>
<tr><td><code><a href="#ns2__loginResponse"> struct ns2__loginResponse </a></code></td><td> webservice_source.h:15 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__login"> struct ns2__login </a></code></td><td> webservice_source.h:15 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__logoutResponse"> struct ns2__logoutResponse </a></code></td><td> webservice_source.h:16 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__logout"> struct ns2__logout </a></code></td><td> webservice_source.h:16 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__keepaliveResponse"> struct ns2__keepaliveResponse </a></code></td><td> webservice_source.h:17 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__keepalive"> struct ns2__keepalive </a></code></td><td> webservice_source.h:17 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__get_directory_infoResponse"> struct ns2__get_directory_infoResponse </a></code></td><td> webservice_source.h:19 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__get_directory_info"> struct ns2__get_directory_info </a></code></td><td> webservice_source.h:19 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__ptz_controlResponse"> struct ns2__ptz_controlResponse </a></code></td><td> webservice_source.h:20 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__ptz_control"> struct ns2__ptz_control </a></code></td><td> webservice_source.h:20 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__start_real_playResponse"> struct ns2__start_real_playResponse </a></code></td><td> webservice_source.h:22 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__start_real_play"> struct ns2__start_real_play </a></code></td><td> webservice_source.h:22 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__stop_real_playResponse"> struct ns2__stop_real_playResponse </a></code></td><td> webservice_source.h:23 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__stop_real_play"> struct ns2__stop_real_play </a></code></td><td> webservice_source.h:23 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__start_play_backResponse"> struct ns2__start_play_backResponse </a></code></td><td> webservice_source.h:25 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__start_play_back"> struct ns2__start_play_back </a></code></td><td> webservice_source.h:25 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__stop_play_backResponse"> struct ns2__stop_play_backResponse </a></code></td><td> webservice_source.h:26 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__stop_play_back"> struct ns2__stop_play_back </a></code></td><td> webservice_source.h:26 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__pause_play_backResponse"> struct ns2__pause_play_backResponse </a></code></td><td> webservice_source.h:28 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__pause_play_back"> struct ns2__pause_play_back </a></code></td><td> webservice_source.h:28 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__restart_play_backResponse"> struct ns2__restart_play_backResponse </a></code></td><td> webservice_source.h:29 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__restart_play_back"> struct ns2__restart_play_back </a></code></td><td> webservice_source.h:29 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td> webservice_source.h:30 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td> webservice_source.h:30 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td> webservice_source.h:30 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td> webservice_source.h:30 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td> webservice_source.h:30 </td><td> yes </td></tr>
</table>

<a name="ns2__loginResponse"></a>

### `struct ns2__loginResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 15, is serialized as XSD type *`ns2:loginResponse`* and is internally used as the operation response element *`<ns2:loginResponse>`* with the response parameters of service operation `ns2__login()`.

[![][1] To top](#)


<a name="ns2__login"></a>

### `struct ns2__login`

This struct is declared in [webservice_source.h](webservice_source.h) at line 15, is serialized as XSD type *`ns2:login`* and is internally used as the operation request element *`<ns2:login>`* with the request parameters of service operation `ns2__login()`.

[![][1] To top](#)


<a name="ns2__logoutResponse"></a>

### `struct ns2__logoutResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 16, is serialized as XSD type *`ns2:logoutResponse`* and is internally used as the operation response element *`<ns2:logoutResponse>`* with the response parameters of service operation `ns2__logout()`.

[![][1] To top](#)


<a name="ns2__logout"></a>

### `struct ns2__logout`

This struct is declared in [webservice_source.h](webservice_source.h) at line 16, is serialized as XSD type *`ns2:logout`* and is internally used as the operation request element *`<ns2:logout>`* with the request parameters of service operation `ns2__logout()`.

[![][1] To top](#)


<a name="ns2__keepaliveResponse"></a>

### `struct ns2__keepaliveResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 17, is serialized as XSD type *`ns2:keepaliveResponse`* and is internally used as the operation response element *`<ns2:keepaliveResponse>`* with the response parameters of service operation `ns2__keepalive()`.

[![][1] To top](#)


<a name="ns2__keepalive"></a>

### `struct ns2__keepalive`

This struct is declared in [webservice_source.h](webservice_source.h) at line 17, is serialized as XSD type *`ns2:keepalive`* and is internally used as the operation request element *`<ns2:keepalive>`* with the request parameters of service operation `ns2__keepalive()`.

[![][1] To top](#)


<a name="ns2__get_directory_infoResponse"></a>

### `struct ns2__get_directory_infoResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 19, is serialized as XSD type *`ns2:get-directory-infoResponse`* and is internally used as the operation response element *`<ns2:get-directory-infoResponse>`* with the response parameters of service operation `ns2__get_directory_info()`.

[![][1] To top](#)


<a name="ns2__get_directory_info"></a>

### `struct ns2__get_directory_info`

This struct is declared in [webservice_source.h](webservice_source.h) at line 19, is serialized as XSD type *`ns2:get-directory-info`* and is internally used as the operation request element *`<ns2:get-directory-info>`* with the request parameters of service operation `ns2__get_directory_info()`.

[![][1] To top](#)


<a name="ns2__ptz_controlResponse"></a>

### `struct ns2__ptz_controlResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 20, is serialized as XSD type *`ns2:ptz-controlResponse`* and is internally used as the operation response element *`<ns2:ptz-controlResponse>`* with the response parameters of service operation `ns2__ptz_control()`.

[![][1] To top](#)


<a name="ns2__ptz_control"></a>

### `struct ns2__ptz_control`

This struct is declared in [webservice_source.h](webservice_source.h) at line 20, is serialized as XSD type *`ns2:ptz-control`* and is internally used as the operation request element *`<ns2:ptz-control>`* with the request parameters of service operation `ns2__ptz_control()`.

[![][1] To top](#)


<a name="ns2__start_real_playResponse"></a>

### `struct ns2__start_real_playResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 22, is serialized as XSD type *`ns2:start-real-playResponse`* and is internally used as the operation response element *`<ns2:start-real-playResponse>`* with the response parameters of service operation `ns2__start_real_play()`.

[![][1] To top](#)


<a name="ns2__start_real_play"></a>

### `struct ns2__start_real_play`

This struct is declared in [webservice_source.h](webservice_source.h) at line 22, is serialized as XSD type *`ns2:start-real-play`* and is internally used as the operation request element *`<ns2:start-real-play>`* with the request parameters of service operation `ns2__start_real_play()`.

[![][1] To top](#)


<a name="ns2__stop_real_playResponse"></a>

### `struct ns2__stop_real_playResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 23, is serialized as XSD type *`ns2:stop-real-playResponse`* and is internally used as the operation response element *`<ns2:stop-real-playResponse>`* with the response parameters of service operation `ns2__stop_real_play()`.

[![][1] To top](#)


<a name="ns2__stop_real_play"></a>

### `struct ns2__stop_real_play`

This struct is declared in [webservice_source.h](webservice_source.h) at line 23, is serialized as XSD type *`ns2:stop-real-play`* and is internally used as the operation request element *`<ns2:stop-real-play>`* with the request parameters of service operation `ns2__stop_real_play()`.

[![][1] To top](#)


<a name="ns2__start_play_backResponse"></a>

### `struct ns2__start_play_backResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 25, is serialized as XSD type *`ns2:start-play-backResponse`* and is internally used as the operation response element *`<ns2:start-play-backResponse>`* with the response parameters of service operation `ns2__start_play_back()`.

[![][1] To top](#)


<a name="ns2__start_play_back"></a>

### `struct ns2__start_play_back`

This struct is declared in [webservice_source.h](webservice_source.h) at line 25, is serialized as XSD type *`ns2:start-play-back`* and is internally used as the operation request element *`<ns2:start-play-back>`* with the request parameters of service operation `ns2__start_play_back()`.

[![][1] To top](#)


<a name="ns2__stop_play_backResponse"></a>

### `struct ns2__stop_play_backResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 26, is serialized as XSD type *`ns2:stop-play-backResponse`* and is internally used as the operation response element *`<ns2:stop-play-backResponse>`* with the response parameters of service operation `ns2__stop_play_back()`.

[![][1] To top](#)


<a name="ns2__stop_play_back"></a>

### `struct ns2__stop_play_back`

This struct is declared in [webservice_source.h](webservice_source.h) at line 26, is serialized as XSD type *`ns2:stop-play-back`* and is internally used as the operation request element *`<ns2:stop-play-back>`* with the request parameters of service operation `ns2__stop_play_back()`.

[![][1] To top](#)


<a name="ns2__pause_play_backResponse"></a>

### `struct ns2__pause_play_backResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 28, is serialized as XSD type *`ns2:pause-play-backResponse`* and is internally used as the operation response element *`<ns2:pause-play-backResponse>`* with the response parameters of service operation `ns2__pause_play_back()`.

[![][1] To top](#)


<a name="ns2__pause_play_back"></a>

### `struct ns2__pause_play_back`

This struct is declared in [webservice_source.h](webservice_source.h) at line 28, is serialized as XSD type *`ns2:pause-play-back`* and is internally used as the operation request element *`<ns2:pause-play-back>`* with the request parameters of service operation `ns2__pause_play_back()`.

[![][1] To top](#)


<a name="ns2__restart_play_backResponse"></a>

### `struct ns2__restart_play_backResponse`

This struct is declared in [webservice_source.h](webservice_source.h) at line 29, is serialized as XSD type *`ns2:restart-play-backResponse`* and is internally used as the operation response element *`<ns2:restart-play-backResponse>`* with the response parameters of service operation `ns2__restart_play_back()`.

[![][1] To top](#)


<a name="ns2__restart_play_back"></a>

### `struct ns2__restart_play_back`

This struct is declared in [webservice_source.h](webservice_source.h) at line 29, is serialized as XSD type *`ns2:restart-play-back`* and is internally used as the operation request element *`<ns2:restart-play-back>`* with the request parameters of service operation `ns2__restart_play_back()`.

[![][1] To top](#)


<a name="SOAP_ENV__Header"></a>

### `struct SOAP_ENV__Header`

This struct is declared in [webservice_source.h](webservice_source.h) at line 30, is the SOAP protocol *`<SOAP-ENV:Header>`* element with message-specific child elements that are mandatory to process when attributed with *`mustUnderstand="true"`*.  Headers are usually added and processed by plugins.  To remove the SOAP Header when sending or returning a message, set `soap->header = NULL`.  Use `soap_header(struct soap *soap)` to allocate a `struct SOAP_ENV__Header` which will be pointed to by `soap->header`, then initialize it with `soap_default_SOAP_ENV__Header(soap, soap->header)` and set one or more of its data members (if any):

*No SOAP headers are applicable*

This struct will be auto-generated when it is not explicitly declared in an interface file, and is declared mutable, meaning that multiple declarations in interface files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Code"></a>

### `struct SOAP_ENV__Code`

This struct is declared in [webservice_source.h](webservice_source.h) at line 30, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is the SOAP protocol *`<SOAP-ENV:Code>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Detail"></a>

### `struct SOAP_ENV__Detail`

This struct is declared in [webservice_source.h](webservice_source.h) at line 30, is the SOAP protocol *`<SOAP-ENV:Detail>`* element with details returned by a service that triggered the error.  Fault details are added and processed by plugins by setting the `detail` (for SOAP 1.1) or `SOAP_ENV__Detail` (for SOAP 1.2) member of `struct SOAP_ENV__Fault` and then setting one ore more of the detail members:

- `char *__any` catch-all XML in literal XML string, see also <code><a href="#_XML"> _XML </a></code>
- `int __type` element *`<fault>`* serialized with C/C++ type `__type` = `SOAP_TYPE_Name`


This struct will be auto-generated when it is not explicitly declared in an interface file, and is declared mutable, meaning that multiple declarations in interface files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Reason"></a>

### `struct SOAP_ENV__Reason`

This struct is declared in [webservice_source.h](webservice_source.h) at line 30, is the SOAP protocol *`<SOAP-ENV:Reason>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Fault"></a>

### `struct SOAP_ENV__Fault`

This struct is declared in [webservice_source.h](webservice_source.h) at line 30, is the SOAP protocol *`<SOAP-ENV:Fault>`* element with fault information and details returned by a service that triggered the error.  At the server side, a fault can be explicitly set within a service operation by calling and returning:

- `int soap_sender_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the sender is at fault (irrecoverable)
- `int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the receiver is at fault (recoverable, sender may retry)

A service operation may also return an HTTP status/error code (201 to 999).

At the client side the (proxy) call returns the error code which is also stored in `soap->error`.  The fault structure is pointed to by `soap->fault`.  The fault can be displayed with:

- `void soap_print_fault(struct soap *soap, FILE *fd)` display fault
- `void soap_print_fault_location(struct soap *soap, FILE *fd)` display the location of the fault in the XML message that caused it
- `void soap_sprint_fault(struct soap *soap, char *buf, size_t len)` write fault to buffer
- `void soap_stream_fault(struct soap *soap, std::ostream&)` write fault to stream
- `const char **soap_faultstring(struct soap *soap)` returns a pointer to the SOAP Fault string/reason to get or set this string
- `const char **soap_faultdetail(struct soap *soap)` returns a pointer to the SOAP Fault detail XML to get or set this string

This struct will be auto-generated when it is not explicitly declared in an interface file and is declared mutable, meaning that multiple declarations in interface files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


## Typedefs {#doc-typedefs}

A typedef type is serializable if its underlying base type is serializable.  Typedefs may declare custom serializers, meaning their underlying types are custom-serialized in XML using serialization rules that differ from the serialization rules of the underlying base type:
<table class="doxtable">
<tr><th> Typedef </th><th> Type </th><th> Declared </th><th> Serializable </th><th> Custom </th></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
</table>

<a name="_XML"></a>

### `_XML`

This typedef is internally generated and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_QName"></a>

### `_QName`

This typedef is internally generated and is a built-in string type to serialize a list of space-separated qualified names (*`xsd:QName`*), such that XML namespace prefixes are normalized to the XML prefixes defined in the [namespace table](#doc-namespaces) or replaced with "URI": when the namespace table has no prefix entry for the URI

[![][1] To top](#)


## Summary of Serializable Types {#doc-types}

Each serializable C/C++ *Type* with binding name *Name* has a set of auto-generated functions:

- `Type *soap_new_Name(struct soap*)` managed allocation and default initialization
- `Type *soap_new_Name(struct soap*, int n)` managed allocation and default initialization of an array `Type[n]`
- `void soap_default_Name(struct soap*, Type*)` initialize or reset non-class *Type* to default)
- `void Type::soap_default(struct soap*)` non-volatile class *Type* reset to default
- `Type *soap_dup_Name(struct soap*, Type *dst, const Type *src)` requires soapcpp2 option -Ec, deep copy `src` to `dst` managed by context or unmanaged when context is NULL, returning `dst` (if `dst` is NULL then allocates `dst` copy)
- `void soap_del_Name(struct soap*, Type*)` requires soapcpp2 option -Ec, deep delete *Type* which must be unmanaged
- `const char *soap_Name2s(struct soap*, Type)` primitive *Type* only, returns string-converted *Type* in temporary string buffer
- `int soap_s2Name(struct soap*, const char*, Type*)` primitive *Type* only, convert string to value, returns `SOAP_OK` or error code
- `int soap_write_Name(struct soap*, const Type*)` serialize *Type* to XML, returns `SOAP_OK` or error code
- `int soap_PUT_Name(struct soap*, const char *URL, const Type*)` REST PUT *Type* in XML, returns `SOAP_OK` or error code
- `int soap_POST_send_Name(struct soap*, const char *URL, const Type*)` REST POST send *Type* in XML (MUST be followed by a `soap_POST_recv_OtherName`), returns `SOAP_OK` or error code
- `int soap_read_Name(struct soap*, Type*)` deserialize *Type* from XML, returns `SOAP_OK` or error code
- `int soap_GET_Name(struct soap*, const char *URL, Type*)` REST GET *Type* from XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_Name(struct soap*, Type*)` REST GET *Type* from XML (after a `soap_POST_send_OtherName`), returns `SOAP_OK` or error code
- `(Type *)soap_malloc(struct soap*, sizeof(Type))` raw managed allocation of primitive *Type* (types that are not structs or classes) without initialization
- `const char *soap_strdup(struct soap*, const char*)` managed allocation and duplication of string
- `const wchar_t *soap_wstrdup(struct soap*, const wchar_t*)` managed allocation and duplication of wide string

Each *Type* also has a unique type id `SOAP_TYPE_Name` that you can use to serialize `void*` in a struct/class by setting the `int __type` member to this type id. The unique type id is also used to distinguish derived class instances from base class instances by calling their `virtual soap_type()` methods that return this type id.

From the toolkit documentation:

- Set `soap->sendfd = fd` to serialize to an `int fd` file descriptor
- Set `soap->os = &os` to serialize to a `std::ostream os`
- Set `soap->recvfd = fd` to deserialize from an `int fd` file descriptor
- Set `soap->is = &is` to deserialize from a `std::istream`
- All managed allocated data is deleted by `soap_destroy(soap)` followed by `soap_end(soap)` with context `soap`

The table below lists the serializable types by *Type*, binding *Name*, *Kind*, and the XSD data binding type and/or element.  Pointers, arrays, and containers of these types are also serializable:

<table class="doxtable">
<tr><th> C/C++ Type </th><th> Name </th><th> Kind </th><th> XSD </th></tr>
<tr><td><code> char </code></td><td><code> byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> int </code></td><td><code> int </code></td><td> int </td><td> xsd:int </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td><code> SOAP_ENV__Fault </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td><code> SOAP_ENV__Reason </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td><code> SOAP_ENV__Detail </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td><code> SOAP_ENV__Code </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td><code> SOAP_ENV__Header </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#ns2__restart_play_back"> struct ns2__restart_play_back </a></code></td><td><code> ns2__restart_play_back </code></td><td> struct </td><td> ns2:restart-play-back </td></tr>
<tr><td><code><a href="#ns2__restart_play_backResponse"> struct ns2__restart_play_backResponse </a></code></td><td><code> ns2__restart_play_backResponse </code></td><td> struct </td><td> ns2:restart-play-backResponse </td></tr>
<tr><td><code><a href="#ns2__pause_play_back"> struct ns2__pause_play_back </a></code></td><td><code> ns2__pause_play_back </code></td><td> struct </td><td> ns2:pause-play-back </td></tr>
<tr><td><code><a href="#ns2__pause_play_backResponse"> struct ns2__pause_play_backResponse </a></code></td><td><code> ns2__pause_play_backResponse </code></td><td> struct </td><td> ns2:pause-play-backResponse </td></tr>
<tr><td><code><a href="#ns2__stop_play_back"> struct ns2__stop_play_back </a></code></td><td><code> ns2__stop_play_back </code></td><td> struct </td><td> ns2:stop-play-back </td></tr>
<tr><td><code><a href="#ns2__stop_play_backResponse"> struct ns2__stop_play_backResponse </a></code></td><td><code> ns2__stop_play_backResponse </code></td><td> struct </td><td> ns2:stop-play-backResponse </td></tr>
<tr><td><code><a href="#ns2__start_play_back"> struct ns2__start_play_back </a></code></td><td><code> ns2__start_play_back </code></td><td> struct </td><td> ns2:start-play-back </td></tr>
<tr><td><code><a href="#ns2__start_play_backResponse"> struct ns2__start_play_backResponse </a></code></td><td><code> ns2__start_play_backResponse </code></td><td> struct </td><td> ns2:start-play-backResponse </td></tr>
<tr><td><code><a href="#ns2__stop_real_play"> struct ns2__stop_real_play </a></code></td><td><code> ns2__stop_real_play </code></td><td> struct </td><td> ns2:stop-real-play </td></tr>
<tr><td><code><a href="#ns2__stop_real_playResponse"> struct ns2__stop_real_playResponse </a></code></td><td><code> ns2__stop_real_playResponse </code></td><td> struct </td><td> ns2:stop-real-playResponse </td></tr>
<tr><td><code><a href="#ns2__start_real_play"> struct ns2__start_real_play </a></code></td><td><code> ns2__start_real_play </code></td><td> struct </td><td> ns2:start-real-play </td></tr>
<tr><td><code><a href="#ns2__start_real_playResponse"> struct ns2__start_real_playResponse </a></code></td><td><code> ns2__start_real_playResponse </code></td><td> struct </td><td> ns2:start-real-playResponse </td></tr>
<tr><td><code><a href="#ns2__ptz_control"> struct ns2__ptz_control </a></code></td><td><code> ns2__ptz_control </code></td><td> struct </td><td> ns2:ptz-control </td></tr>
<tr><td><code><a href="#ns2__ptz_controlResponse"> struct ns2__ptz_controlResponse </a></code></td><td><code> ns2__ptz_controlResponse </code></td><td> struct </td><td> ns2:ptz-controlResponse </td></tr>
<tr><td><code><a href="#ns2__get_directory_info"> struct ns2__get_directory_info </a></code></td><td><code> ns2__get_directory_info </code></td><td> struct </td><td> ns2:get-directory-info </td></tr>
<tr><td><code><a href="#ns2__get_directory_infoResponse"> struct ns2__get_directory_infoResponse </a></code></td><td><code> ns2__get_directory_infoResponse </code></td><td> struct </td><td> ns2:get-directory-infoResponse </td></tr>
<tr><td><code><a href="#ns2__keepalive"> struct ns2__keepalive </a></code></td><td><code> ns2__keepalive </code></td><td> struct </td><td> ns2:keepalive </td></tr>
<tr><td><code><a href="#ns2__keepaliveResponse"> struct ns2__keepaliveResponse </a></code></td><td><code> ns2__keepaliveResponse </code></td><td> struct </td><td> ns2:keepaliveResponse </td></tr>
<tr><td><code><a href="#ns2__logout"> struct ns2__logout </a></code></td><td><code> ns2__logout </code></td><td> struct </td><td> ns2:logout </td></tr>
<tr><td><code><a href="#ns2__logoutResponse"> struct ns2__logoutResponse </a></code></td><td><code> ns2__logoutResponse </code></td><td> struct </td><td> ns2:logoutResponse </td></tr>
<tr><td><code><a href="#ns2__login"> struct ns2__login </a></code></td><td><code> ns2__login </code></td><td> struct </td><td> ns2:login </td></tr>
<tr><td><code><a href="#ns2__loginResponse"> struct ns2__loginResponse </a></code></td><td><code> ns2__loginResponse </code></td><td> struct </td><td> ns2:loginResponse </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> _QName </code></td><td> string </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> _XML </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code> char * </code></td><td><code> string </code></td><td> string </td><td> xsd:string </td></tr>
</table>

[![][1] To top](#)


## Web Service Class sipgwService {#doc-server}

This service class is declared in [soapsipgwService.h](soapsipgwService.h) and defined in [soapsipgwService.cpp](soapsipgwService.cpp):

    class SOAP_CMAC sipgwService {
      public:
        /// Context to manage service IO and data
        struct soap *soap;
        bool soap_own;  ///< flag indicating that this context is owned by this service when context is shared
        /// Variables globally declared in webservice_source.h, if any
        /// Construct a service with new managing context
        sipgwService();
        /// Copy constructor
        sipgwService(const sipgwService&);
        /// Construct service given a shared managing context
        sipgwService(struct soap*);
        /// Constructor taking input+output mode flags for the new managing context
        sipgwService(soap_mode iomode);
        /// Constructor taking input and output mode flags for the new managing context
        sipgwService(soap_mode imode, soap_mode omode);
        /// Destructor deletes non-shared managing context only (use destroy() to delete deserialized data)
        virtual ~sipgwService();
        /// Delete all deserialized data (with soap_destroy() and soap_end())
        virtual void destroy();
        /// Delete all deserialized data and reset to defaults
        virtual void reset();
        /// Initializer used by constructors
        virtual void sipgwService_init(soap_mode imode, soap_mode omode);
        /// Return a copy that has a new managing context with the same engine state
        virtual sipgwService *copy() SOAP_PURE_VIRTUAL_COPY;
        /// Copy assignment
        sipgwService& operator=(const sipgwService&);
        /// Close connection (normally automatic)
        virtual int soap_close_socket();
        /// Force close connection (can kill a thread blocked on IO)
        virtual int soap_force_close_socket();
        /// Return sender-related fault to sender
        virtual int soap_senderfault(const char *string, const char *detailXML);
        /// Return sender-related fault with SOAP 1.2 subcode to sender
        virtual int soap_senderfault(const char *subcodeQName, const char *string, const char *detailXML);
        /// Return receiver-related fault to sender
        virtual int soap_receiverfault(const char *string, const char *detailXML);
        /// Return receiver-related fault with SOAP 1.2 subcode to sender
        virtual int soap_receiverfault(const char *subcodeQName, const char *string, const char *detailXML);
        /// Print fault
        virtual void soap_print_fault(FILE*);
    #ifndef WITH_LEAN
    #ifndef WITH_COMPAT
        /// Print fault to stream
        virtual void soap_stream_fault(std::ostream&);
    #endif
        /// Write fault to buffer
        virtual char *soap_sprint_fault(char *buf, size_t len);
    #endif
        /// Disables and removes SOAP Header from message by setting soap->header = NULL
        virtual void soap_noheader();
        /// Get SOAP Header structure (i.e. soap->header, which is NULL when absent)
        virtual ::SOAP_ENV__Header *soap_header();
    #ifndef WITH_NOIO
        /// Run simple single-thread (iterative, non-SSL) service on port until a connection error occurs (returns SOAP_OK or error code), use this->bind_flag = SO_REUSEADDR to rebind for immediate rerun
        virtual int run(int port);
    #if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
        /// Run simple single-thread SSL service on port until a connection error occurs (returns SOAP_OK or error code), use this->bind_flag = SO_REUSEADDR to rebind for immediate rerun
        virtual int ssl_run(int port);
    #endif
        /// Bind service to port (returns master socket or SOAP_INVALID_SOCKET)
        virtual SOAP_SOCKET bind(const char *host, int port, int backlog);
        /// Accept next request (returns socket or SOAP_INVALID_SOCKET)
        virtual SOAP_SOCKET accept();
    #if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
        /// When SSL is used, after accept() should perform and accept SSL handshake
        virtual int ssl_accept();
    #endif
    #endif
        /// After accept() serve this request (returns SOAP_OK or error code)
        virtual int serve();
        /// Used by serve() to dispatch a request (returns SOAP_OK or error code)
        virtual int dispatch();
        virtual int dispatch(struct soap *soap);
        ///
        /// Service operations are listed below (you should define these)
        /// Note: compile with -DWITH_PURE_VIRTUAL for pure virtual methods
        ///
        /// Web service operation 'login' (returns SOAP_OK or error code)
        virtual int login(char *user_id, char *password, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'logout' (returns SOAP_OK or error code)
        virtual int logout(char *user_id, char *password, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'keepalive' (returns SOAP_OK or error code)
        virtual int keepalive(char *user_id, char *password, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'get-directory-info' (returns SOAP_OK or error code)
        virtual int get_directory_info(char *target_dev_id, char *target_realm, char **directory_info_buf_out) SOAP_PURE_VIRTUAL;
        /// Web service operation 'ptz-control' (returns SOAP_OK or error code)
        virtual int ptz_control(char *target_dev_id, char *target_realm, int ptz, int ptz_speed, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'start-real-play' (returns SOAP_OK or error code)
        virtual int start_real_play(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'stop-real-play' (returns SOAP_OK or error code)
        virtual int stop_real_play(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'start-play-back' (returns SOAP_OK or error code)
        virtual int start_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char *start_time, char *end_time, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'stop-play-back' (returns SOAP_OK or error code)
        virtual int stop_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char *start_time, char *end_time, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'pause-play-back' (returns SOAP_OK or error code)
        virtual int pause_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;
        /// Web service operation 'restart-play-back' (returns SOAP_OK or error code)
        virtual int restart_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;
    };

Use the service request dispatcher to accept and process service requests:

- `int serve()` serves requests by calling one of the service methods that matches the request.  Returns `SOAP_OK` or an error code.  This function supports CGI by accepting a request on stdin and sending the response to stdout, and FastCGI.  To serve over HTTP(S), use the following functions to establish a connection:

- `SOAP_SOCKET bind(const char *host, int port, int backlog)` returns master socket bound to port (and restricted to host name, if not NULL) or `SOAP_INVALID_SOCKET`
- `SOAP_SOCKET accept()` accepts connection and returns socket when accepted, or `SOAP_INVALID_SOCKET`
- `int soap_ssl_accept()` performs SSL handshake and returns `SOAP_OK` when successful or an error code, invoke this method after `accept()` to accept SSL/TLS connection

### Service Operation `sipgwService::login()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 15 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'login' (returns SOAP_OK or error code)
        virtual int login(char *user_id, char *password, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *password` is optional
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::logout()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 16 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'logout' (returns SOAP_OK or error code)
        virtual int logout(char *user_id, char *password, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *password` is optional
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::keepalive()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 17 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'keepalive' (returns SOAP_OK or error code)
        virtual int keepalive(char *user_id, char *password, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *password` is optional
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::get-directory-info()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 19 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `directory_info_buf_out` set or return an error code:

        /// Web service operation 'get-directory-info' (returns SOAP_OK or error code)
        virtual int get_directory_info(char *target_dev_id, char *target_realm, char **directory_info_buf_out) SOAP_PURE_VIRTUAL;

where:

- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char **directory_info_buf_out` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `directory_info_buf_out` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::ptz-control()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 20 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'ptz-control' (returns SOAP_OK or error code)
        virtual int ptz_control(char *target_dev_id, char *target_realm, int ptz, int ptz_speed, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `int ptz` is required
- `int ptz_speed` is required
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::start-real-play()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 22 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'start-real-play' (returns SOAP_OK or error code)
        virtual int start_real_play(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char *media_recv_ip` is optional
- `int media_recv_port` is required
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::stop-real-play()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 23 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'stop-real-play' (returns SOAP_OK or error code)
        virtual int stop_real_play(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char *media_recv_ip` is optional
- `int media_recv_port` is required
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::start-play-back()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 25 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'start-play-back' (returns SOAP_OK or error code)
        virtual int start_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char *start_time, char *end_time, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char *media_recv_ip` is optional
- `int media_recv_port` is required
- `char *start_time` is optional
- `char *end_time` is optional
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::stop-play-back()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 26 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'stop-play-back' (returns SOAP_OK or error code)
        virtual int stop_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char *start_time, char *end_time, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char *media_recv_ip` is optional
- `int media_recv_port` is required
- `char *start_time` is optional
- `char *end_time` is optional
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::pause-play-back()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 28 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'pause-play-back' (returns SOAP_OK or error code)
        virtual int pause_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char *media_recv_ip` is optional
- `int media_recv_port` is required
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


### Service Operation `sipgwService::restart-play-back()`

This service operation is declared in [webservice_source.h](webservice_source.h) at line 29 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action ""
- Default service endpoint URL "http://192.168.2.128:9800/SipGwSvr"
- Operation namespace prefix `ns2` and URI "[urn:sipgw](#doc-namespaces)"

The following service class method must be defined in the service back-end code and will be called by the service dispatcher `sipgwService::serve(soap)`, and should return `SOAP_OK` with the result value `result` set or return an error code:

        /// Web service operation 'restart-play-back' (returns SOAP_OK or error code)
        virtual int restart_play_back(char *user_id, char *target_dev_id, char *target_realm, char *media_recv_ip, int media_recv_port, char **result) SOAP_PURE_VIRTUAL;

where:

- `char *user_id` is optional
- `char *target_dev_id` is optional
- `char *target_realm` is optional
- `char *media_recv_ip` is optional
- `int media_recv_port` is required
- `char **result` is the service operation response, which is a non-NULL pointer to a `char *` that the service operation should populate with the response data

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `result` to the result, or return an error code

[![][1] To top](#)


## Schemas and Namespaces {#doc-namespaces}

The following schemas and namespaces are used in addition to the predefined SOAP and built-in XSD namespaces:

- Prefix `ns2` is bound to namespace URI *`urn:sipgw`* of service WSDL [sipgw.wsdl](sipgw.wsdl) and schema [ns2.xsd](ns2.xsd) with local element form default *`unqualified`* and attribute form default *`unqualified`*

The following namespace table is saved to sipgw.nsmap:

    struct Namespace namespaces[] = {
        {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
        {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
        {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
        {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
        {"ns2", "urn:sipgw", NULL, NULL},
        {NULL, NULL, NULL, NULL}
    };

The table binds XML namespace prefixes (first column) to namespace URIs (second column), similar to xmlns:prefix="URI" in XML.  The third column is a URI pattern with `*` wildcards that is also accepted as a valid namespace URI for inbound XML messages.  The fourth column is NULL.  This table is globally defined for the gSOAP engine.  The engine context will look for it unless you compiled the gSOAP source codes with `-DWITH_NONAMESPACES`.  You must assign this or another namespace table with `soap_set_namespaces(struct soap *soap, struct Namespace *namespaces)` after initializing the context and before processing XML.

[![][1] To top](#)



  [1]: https://www.genivia.com/images/go-up.png

--------------------------------------------------------------------------------

_Generated on Wed Nov 21 2018 03:11:11 UTC by soapcpp2 v2.8.70 for webservice_source.h._
_The gSOAP XML Web services tools are Copyright (C) Robert van Engelen, Genivia Inc. All Rights Reserved._
